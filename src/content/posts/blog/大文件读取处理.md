---
title: 大文件内容读取以及文件处理思路
published: 2025-10-15
tips:
  - 文件内容处理的方式？
  - 大文件或庞大数据读取优化思路? 
  - 缓存如何使用？
  - 缓存溢出风险？
tags:
  - 记录
  - 推荐
  - 学习
lang: zh
abbrlink:  file-readthinking
---
### 0. 介绍

> 通过浏览github和一些博客，了解到的一些有意思的开源内容和处理的思路，记录一下。以下数据均以本人个人电脑测算结果：32G内存，16核，JDK21

### 1. 文件内容处理的方式

#### 1.1 内容的类化

> 读取文本内容时，将文本的内容进行归类处理，参考编程语言的AST语法树的处理方式，将文本内容进行分类，比如：关键字、标识符、字面量、运算符、注释、空白字符等等。<br/>

#### 1.2 内容分页和流式处理

> 对于超过内存大小的文件，为了避免发生内存溢出问题，可以采用分页或者流式处理的方式，将文件内容分成多个小块，逐个处理，而不是一次性读取整个文件。<br/>
> 而流式的惰性处理可以根据需要再进行处理，比如：判断文件内容前缀，我们只需要加载事先定义的固定偏移量字符而不需要额外的空间，类似于数组的提前规划。<br/>

#### 1.3 内容的压缩

> 对于不同数据的分类，可以利用位图将多字节的数据，例如`String`转变为`Hash`值进行存储（可以参考布隆过滤器的设计思路），可以大幅度减少内存占用。<br/>
> 这种方案需要具体讨论，例如压缩还原问题？ 压缩率如何？冲突问题？直白的说压缩会带来新问题，需要提前考虑。<br/>

#### 1.4 文件的快速写入

> [ACM Queue](https://queue.acm.org/detail.cfm?id=1563874) 线性写入性能约为 600MB/秒，但随机写入的性能仅约为 100k/秒——相差超过 6000 倍！<br/>
> [Kafka-Logs](https://github.com/AutoMQ/automq/wiki/Kafka-Logs:-Concept-&-How-It-Works-&-Format)

### 2. 大文件的读取

* 大文件优化挑战 <br/>

> 以下是一个大文件的优化挑战，要求必须使用`java`完成，数据集大小为13G，格式为: {station};{temperature};
> 要求处理{station}的最大、最小、平均值并输出 {Abha=-35.0/18.0/70.7......} <br/>
> ::github{repo="gunnarmorling/1brc"}

> 直接使用NIO的流式处理，本地跑完大概是130s左右

```java
        long start = System.nanoTime();
        Map<String, ResultRow> measurements = new TreeMap<>(Files.lines(Paths.get(FILE))
                .parallel()
                .map(l -> new Measurement(l.split(";")))
                .collect(Collectors.groupingBy(m -> m.station(), collector)));
        long end = System.nanoTime();
        System.out.printf("%.2f%n", (end - start) * 1E-9);
        System.out.println(measurements);
```

:::fold[优化方案1：结果 130s ->3s(ps: 这不是最快的方案，可以查看上述git：gunnarmorling/1brc 的测试结果)]

> 这里插嘴说一下，有时候不需要极致的优化，譬如你根据特定需要直接重写数据结构进行优化（带缓存的栈之类的），这种可能会导致可读性很差。<br/>
> 而且,对于人类感知而言做到1-2s其实是可以接受的，比如动画，30帧（1s内30张图片切换）达到一定帧数，人眼基本就无法分辨<br/>
>
> * MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制;<br>
> * MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。<br>

```txt
// 输入示例（假设在ByteBuffer中）
"Station1;12.3\nStation2;45.6\n"

// 处理过程
1. 读取第一个8字节："Station1;"
2. 检测到分号(;)位于第9字节
3. 提取站点名称："Station1"
4. 解析测量值：123（内部表示为整数，乘以10）
5. 更新Station1的统计信息：最小值=123，最大值=123，总和=123，计数=1
6. 重复处理下一行

// 最终结果（统计信息）

```

以完整行 `Station1;12.3\n `为例:


| 变量           | 值                 | 意义                     |
| -------------- | ------------------ | ------------------------ |
| keyLong        | 0x316e6f6974617453 | 包含"Station1"的8字节    |
| valueSepMark   | 0x0080000000000000 | 标记分号位置的位掩码     |
| tailBits       | 48                 | 分号在字节块中的位位置   |
| valueOffset    | 6                  | 分号在字节块中的字节偏移 |
| valueLong      | 0x6174530A332E3231 | 包含"12.3\\nSta"的8字节  |
| decimalSepMark | 20                 | 小数点的位位置(假设)     |
| measurement    | 123                | 解析后的测量值(乘以10)   |

```java
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.TreeMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;


public class CalculateAverage_gonix {


    private static final String FILE = ".\\src\\test\\java\\measurements.txt";

    public static void main(String[] args) throws IOException {
        long start = System.nanoTime();

        var file = new RandomAccessFile(FILE, "r");
        var res = buildChunks(file).stream().parallel()
                .flatMap(chunk -> new Aggregator().processChunk(chunk).stream())
                .collect(Collectors.toMap(
                        Aggregator.Entry::getKey,
                        Aggregator.Entry::getValue,
                        Aggregator.Entry::add, // merge values
                        TreeMap::new));

        long end = System.nanoTime();
        System.out.println("Elapsed time: " + (end - start) * 1e-9 );
        System.out.println(res);
        System.out.close();
    }

    /**
     *  文件分页
     * MappedByteBuffer: MMP内存映射技术，操作虚拟RAM映射到物理RAM，
     */
    private static List<MappedByteBuffer> buildChunks(RandomAccessFile file) throws IOException {
        var fileSize = file.length();//13795417691
        // 分页偏移保持在Integer.MAX_VALUE - 512下，避免溢出（512是为了留出空间操作）
        var chunkSize = Math.min(Integer.MAX_VALUE - 512, fileSize / Runtime.getRuntime().availableProcessors()); //862213605（13795417691/16）
        if (chunkSize <= 0) {
            chunkSize = fileSize;
        }
        var chunks = new ArrayList<MappedByteBuffer>((int) (fileSize / chunkSize) + 1);//  17/16 => 1x16 + 1 
        var start = 0L;
        while (start < fileSize) {
            var pos = start + chunkSize;
            if (pos < fileSize) {
                file.seek(pos);
                //保证数据的完整性，即 test;23 这种数据不会被截断
                while (file.read() != '\n') {
                    pos += 1; // +11
                }
                pos += 1;
            }
            else {
                pos = fileSize;
            }
            var buf = file.getChannel().map(FileChannel.MapMode.READ_ONLY, start, pos - start);//pos = 862213616
            buf.order(ByteOrder.nativeOrder()); // 字节序，这个是考虑系统是大端or小端（就是数据的高位在地址前还是低位在地址前） https://zhuanlan.zhihu.com/p/680366680
            chunks.add(buf);
            start = pos;
        }
        return chunks;
    }

    private static class Aggregator {
        private static final int MAX_STATIONS = 10_000;
        private static final int MAX_STATION_SIZE = Math.ceilDiv(100, 8) + 5;
        private static final int INDEX_SIZE = 1024 * 1024;
        private static final int INDEX_MASK = INDEX_SIZE - 1;
        private static final int FLD_COUNT = 0;
        private static final int FLD_SUM = 1;
        private static final int FLD_MIN = 2;
        private static final int FLD_MAX = 3;

        // Poor man's hash map: hash code to offset in `mem`.
        private final int[] index;

        // Contiguous storage of key (station name) and stats fields of all
        // unique stations.
        // The idea here is to improve locality so that stats fields would
        // possibly be already in the CPU cache after we are done comparing
        // the key.
        private final long[] mem;
        private int memUsed;

        Aggregator() {
            index = new int[INDEX_SIZE];
            mem = new long[MAX_STATION_SIZE * MAX_STATIONS];
        }

        Aggregator processChunk(MappedByteBuffer buf) {
            // To avoid checking if it is safe to read a whole long near the
            // end of a chunk, we copy last couple of lines to a padded buffer
            // and process that part separately.
            int limit = buf.limit();//862213616 
            int pos = Math.max(limit - 16, -1); //避免缓冲区溢出，buf.getLong(pos);需要读取8个字节
            while (pos >= 0 && buf.get(pos) != '\n') { //使得数据从换行符开始，保证数据的完整性
                pos--;
            }
            pos++;
            if (pos > 0) {
                processChunkLongs(buf, pos);
            }
            // 处理换行符后的尾部数据
            int tailLen = limit - pos;
            var tailBuf = ByteBuffer.allocate(tailLen + 8).order(ByteOrder.nativeOrder());
            buf.get(pos, tailBuf.array(), 0, tailLen);
            processChunkLongs(tailBuf, tailLen);
            return this;
        }

        /** 
         * "Station1;12.3\nStation2;45.6\n"  前8字节：Station1;12.3\n => Station1 
         * valueSepMark判断读取的8字节中是否包含分号';'，并进行处理
        */
        Aggregator processChunkLongs(ByteBuffer buf, int limit) {
            int pos = 0;
            while (pos < limit) {

                int start = pos;
                long keyLong = buf.getLong(pos);
                /**
                 * - 调用 valueSepMark 方法检测8字节中是否包含分号 ;
                 * - 使用位操作并行检查8个字节，比逐字节检查高效得多
                 */
                long valueSepMark = valueSepMark(keyLong); 
                if (valueSepMark != 0) {
                    int tailBits = tailBits(valueSepMark);
                    pos += valueOffset(tailBits);
                    // assert (UNSAFE.getByte(pos - 1) == ';') : "Expected ';' (1), pos=" + (pos - startAddr);
                    // 提取`;`前站点信息
                    long tailAndLen = tailAndLen(tailBits, keyLong, pos - start - 1);

                    long valueLong = buf.getLong(pos); // 测量值
                    int decimalSepMark = decimalSepMark(valueLong);
                    pos += nextKeyOffset(decimalSepMark);
                    // assert (UNSAFE.getByte(pos - 1) == '\n') : "Expected '\\n' (1), pos=" + (pos - startAddr);
                    int measurement = decimalValue(decimalSepMark, valueLong);

                    add1(buf, start, tailAndLen, hash(hash1(tailAndLen)), measurement);
                    continue;
                }

                pos += 8;
                long keyLong1 = keyLong;
                keyLong = buf.getLong(pos);
                valueSepMark = valueSepMark(keyLong);
                if (valueSepMark != 0) {
                    int tailBits = tailBits(valueSepMark);
                    pos += valueOffset(tailBits);
                    // assert (UNSAFE.getByte(pos - 1) == ';') : "Expected ';' (2), pos=" + (pos - startAddr);
                    long tailAndLen = tailAndLen(tailBits, keyLong, pos - start - 1);

                    long valueLong = buf.getLong(pos);
                    int decimalSepMark = decimalSepMark(valueLong);
                    pos += nextKeyOffset(decimalSepMark);
                    // assert (UNSAFE.getByte(pos - 1) == '\n') : "Expected '\\n' (2), pos=" + (pos - startAddr);
                    int measurement = decimalValue(decimalSepMark, valueLong);

                    add2(buf, start, keyLong1, tailAndLen, hash(hash(hash1(keyLong1), tailAndLen)), measurement);
                    continue;
                }

                long hash = hash1(keyLong1);
                do {
                    pos += 8;
                    hash = hash(hash, keyLong);
                    keyLong = buf.getLong(pos);
                    valueSepMark = valueSepMark(keyLong);
                } while (valueSepMark == 0);
                int tailBits = tailBits(valueSepMark);
                pos += valueOffset(tailBits);
                // assert (UNSAFE.getByte(pos - 1) == ';') : "Expected ';' (N), pos=" + (pos - startAddr);
                long tailAndLen = tailAndLen(tailBits, keyLong, pos - start - 1);
                hash = hash(hash, tailAndLen);

                long valueLong = buf.getLong(pos);
                int decimalSepMark = decimalSepMark(valueLong);
                pos += nextKeyOffset(decimalSepMark);
                // assert (UNSAFE.getByte(pos - 1) == '\n') : "Expected '\\n' (N), pos=" + (pos - startAddr);
                int measurement = decimalValue(decimalSepMark, valueLong);

                addN(buf, start, tailAndLen, hash(hash), measurement);
            }

            return this;
        }

        public Stream<Entry> stream() {
            return Arrays.stream(index)
                    .filter(offset -> offset != 0)
                    .mapToObj(offset -> new Entry(mem, offset));
        }

        private static long hash1(long value) {
            return value;
        }

        private static long hash(long hash, long value) {
            return hash ^ value;
        }

        private static int hash(long hash) {
            hash *= 0x9E3779B97F4A7C15L; // Fibonacci hashing multiplier
            return (int) (hash >>> 39);
        }

        private static long valueSepMark(long keyLong) {
            // Seen this trick used in multiple other solutions.
            // Nice breakdown here: https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord
            long match = keyLong ^ 0x3B3B3B3B_3B3B3B3BL; // 3B == ';'
            match = (match - 0x01010101_01010101L) & (~match & 0x80808080_80808080L);
            return match;
        }

        /**
         * 计算无符号移位7以后0的个数
         */
        private static int tailBits(long valueSepMark) {
            return Long.numberOfTrailingZeros(valueSepMark >>> 7);
        }

        /**
         * ';' 在8字节的第几位
         */
        private static int valueOffset(int tailBits) {
            return (int) (tailBits >>> 3) + 1;
        }

        private static long tailAndLen(int tailBits, long keyLong, long keyLen) {
            long tailMask = ~(-1L << tailBits);
            long tail = keyLong & tailMask;
            return (tail << 8) | ((keyLen >> 3) & 0xFF);
        }

        private static int decimalSepMark(long value) {
            // Seen this trick used in multiple other solutions.
            // Looks like the original author is @merykitty.

            // The 4th binary digit of the ascii of a digit is 1 while
            // that of the '.' is 0. This finds the decimal separator
            // The value can be 12, 20, 28
            return Long.numberOfTrailingZeros(~value & 0x10101000);
        }

        private static int decimalValue(int decimalSepMark, long value) {
            // Seen this trick used in multiple other solutions.
            // Looks like the original author is @merykitty.

            int shift = 28 - decimalSepMark;
            // signed is -1 if negative, 0 otherwise
            long signed = (~value << 59) >> 63;
            long designMask = ~(signed & 0xFF);
            // Align the number to a specific position and transform the ascii code
            // to actual digit value in each byte
            long digits = ((value & designMask) << shift) & 0x0F000F0F00L;

            // Now digits is in the form 0xUU00TTHH00 (UU: units digit, TT: tens digit, HH: hundreds digit)
            // 0xUU00TTHH00 * (100 * 0x1000000 + 10 * 0x10000 + 1) =
            // 0x000000UU00TTHH00 +
            // 0x00UU00TTHH000000 * 10 +
            // 0xUU00TTHH00000000 * 100
            // Now TT * 100 has 2 trailing zeroes and HH * 100 + TT * 10 + UU < 0x400
            // This results in our value lies in the bit 32 to 41 of this product
            // That was close :)
            long absValue = ((digits * 0x640a0001) >>> 32) & 0x3FF;
            return (int) ((absValue ^ signed) - signed);
        }

        private static int nextKeyOffset(int decimalSepMark) {
            return (decimalSepMark >>> 3) + 3;
        }

        private void add1(ByteBuffer buf, int start, long tailAndLen, int hash, int measurement) {
            int idx = hash & INDEX_MASK;
            for (; index[idx] != 0; idx = (idx + 1) & INDEX_MASK) {
                if (update1(index[idx], tailAndLen, measurement)) {
                    return;
                }
            }
            index[idx] = create(buf, start, tailAndLen, measurement);
        }

        private void add2(ByteBuffer buf, int start, long keyLong, long tailAndLen, int hash, int measurement) {
            int idx = hash & INDEX_MASK;
            for (; index[idx] != 0; idx = (idx + 1) & INDEX_MASK) {
                if (update2(index[idx], keyLong, tailAndLen, measurement)) {
                    return;
                }
            }
            index[idx] = create(buf, start, tailAndLen, measurement);
        }

        private void addN(ByteBuffer buf, int start, long tailAndLen, int hash, int measurement) {
            int idx = hash & INDEX_MASK;
            for (; index[idx] != 0; idx = (idx + 1) & INDEX_MASK) {
                if (updateN(index[idx], buf, start, tailAndLen, measurement)) {
                    return;
                }
            }
            index[idx] = create(buf, start, tailAndLen, measurement);
        }

        private int create(ByteBuffer buf, int start, long tailAndLen, int measurement) {
            int offset = memUsed;

            mem[offset] = tailAndLen;

            int memPos = offset + 1;
            int memEnd = memPos + (int) (tailAndLen & 0xFF);
            int bufPos = start;
            while (memPos < memEnd) {
                mem[memPos] = buf.getLong(bufPos);
                memPos += 1;
                bufPos += 8;
            }

            mem[memPos + FLD_MIN] = measurement;
            mem[memPos + FLD_MAX] = measurement;
            mem[memPos + FLD_SUM] = measurement;
            mem[memPos + FLD_COUNT] = 1;
            memUsed = memPos + 4;

            return offset;
        }

        private boolean update1(int offset, long tailAndLen, int measurement) {
            if (mem[offset] != tailAndLen) {
                return false;
            }
            updateStats(offset + 1, measurement);
            return true;
        }

        private boolean update2(int offset, long keyLong, long tailAndLen, int measurement) {
            if (mem[offset] != tailAndLen || mem[offset + 1] != keyLong) {
                return false;
            }
            updateStats(offset + 2, measurement);
            return true;
        }

        private boolean updateN(int offset, ByteBuffer buf, int start, long tailAndLen, int measurement) {
            var mem = this.mem;
            if (mem[offset] != tailAndLen) {
                return false;
            }
            int memPos = offset + 1;
            int memEnd = memPos + (int) (tailAndLen & 0xFF);
            int bufPos = start;
            while (memPos < memEnd) {
                if (mem[memPos] != buf.getLong(bufPos)) {
                    return false;
                }
                memPos += 1;
                bufPos += 8;
            }
            updateStats(memPos, measurement);
            return true;
        }

        private void updateStats(int memPos, int measurement) {
            mem[memPos + FLD_COUNT] += 1;
            mem[memPos + FLD_SUM] += measurement;
            if (measurement < mem[memPos + FLD_MIN]) {
                mem[memPos + FLD_MIN] = measurement;
            }
            if (measurement > mem[memPos + FLD_MAX]) {
                mem[memPos + FLD_MAX] = measurement;
            }
        }

        public static class Entry {
            private final long[] mem;
            private final int offset;
            private String key;

            Entry(long[] mem, int offset) {
                this.mem = mem;
                this.offset = offset;
            }

            public String getKey() {
                if (key == null) {
                    int pos = this.offset;
                    long tailAndLen = mem[pos++];
                    int keyLen = (int) (tailAndLen & 0xFF);
                    var tmpBuf = ByteBuffer.allocate((keyLen << 3) + 8).order(ByteOrder.nativeOrder());
                    for (int i = 0; i < keyLen; i++) {
                        tmpBuf.putLong(mem[pos++]);
                    }
                    long tail = tailAndLen >>> 8;
                    tmpBuf.putLong(tail);
                    int keyLenBytes = (keyLen << 3) + 8 - (Long.numberOfLeadingZeros(tail) >> 3);
                    key = new String(tmpBuf.array(), 0, keyLenBytes, StandardCharsets.UTF_8);
                }
                return key;
            }

            public Entry add(Entry other) {
                int fldOffset = (int) (mem[offset] & 0xFF) + 1;
                int pos = offset + fldOffset;
                int otherPos = other.offset + fldOffset;
                long[] otherMem = other.mem;
                mem[pos + FLD_MIN] = Math.min((int) mem[pos + FLD_MIN], (int) otherMem[otherPos + FLD_MIN]);
                mem[pos + FLD_MAX] = Math.max((int) mem[pos + FLD_MAX], (int) otherMem[otherPos + FLD_MAX]);
                mem[pos + FLD_SUM] += otherMem[otherPos + FLD_SUM];
                mem[pos + FLD_COUNT] += otherMem[otherPos + FLD_COUNT];
                return this;
            }

            public Entry getValue() {
                return this;
            }

            @Override
            public String toString() {
                int pos = offset + (int) (mem[offset] & 0xFF) + 1;
                return round(mem[pos + FLD_MIN])
                        + "/" + round(((double) mem[pos + FLD_SUM]) / mem[pos + FLD_COUNT])
                        + "/" + round(mem[pos + FLD_MAX]);
            }

            private static double round(double value) {
                return Math.round(value) / 10.0;
            }
        }
    }

}

```

:::

- [深入浅出MappedByteBuffer](https://www.jianshu.com/p/f90866dcbffc)
- [IBM AIX 7.3 了解内存映射](https://www.ibm.com/docs/zh/aix/7.3.0?topic=memory-understanding-mapping)
- [Linux 内存映射](https://linux-kernel-labs.github.io/refs/heads/master/labs/memory_mapping.html)

### 3. 大文件写入
 ** pass **

> 预留内容

> 内容压缩 + 线性写入

