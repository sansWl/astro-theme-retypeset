---
title: 文件锁实现
published: 2025-08-11
tags: 
  - 锁
lang: zh
abbrlink: randomaccess-file-lock
---

### 锁的介绍
>锁是一种同步机制，用于解决并发情况下访问共享资源时的竞争问题。而解决并发问题需要满足以下条件：原子性，可见性，互斥性。<br>

> 原子性：一个操作是不可分割的，要么全部完成，要么全部不完成。<br>
> 可见性：一个线程对共享资源的修改，其他线程立即可以看到。<br>
> 互斥性：同一时刻，只有一个线程可以访问共享资源。<br>

### 文件锁的作用
>为什么使用文件锁？<br>
> 对已经启动的单机Java项目而言，使用`synchronized` 或 `ReentrantLock` 来实现同步机制是最简单的选择。但是，在分布式环境下和项目启动时，使用文件锁可以更好地控制并发访问或阻止项目的重复启动。MQTT 利用文件锁保证客户端连接唯一性，避免重复连接。<br>

![MQTT](https://img2024.cnblogs.com/blog/3426265/202509/3426265-20250921060131376-867053781.png)

```java
public static void main(String[] args){
        InstanceLockByFile fileLock = InstanceLockByFile.getFileLock();
        fileLock.release(); //注册关闭钩子，项目结束时自动释放锁
        if (fileLock.getInstanceLock()) {
            // 如果已经有锁实例，说明已经有其他进程启动了，退出程序
             System.exit(1);
        }
        SpringApplication.run(App.class, args);
    }
```


### 文件锁的实现
> 譬如 `Zookeeper` 利用的 Znode 和 watch 机制，实现的分布式锁就是利用了文件创建的唯一性。<br>
> 利用创建文件和获取文件的读写权限来满足互斥、原子和可见性，实现文件锁。
```java
/**
 * 文件锁实现利用RandomAccessFile来实现,
 * 注意如果你希望的是分布式或可多次创建的锁，
 * 文件名需要保证唯一性，譬如分布式id处理文件名，UUID等。
 */
    File shutdownServerFile = new File("./");
    rf = new RandomAccessFile(new File(shutdownServerFile.getCanonicalPath() + "/lock.txt"), "rws");
    lock = rf.getChannel().tryLock();

```
```java
/**
 * 释放锁
 */
public void release(){
                Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                    try {
                        rf.close();
                        if (rf.getChannel().isOpen()){
                            lock.close();
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }));
        }
```