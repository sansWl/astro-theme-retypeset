---
title: é«˜çº§è¯­è¨€çš„å®ç°åŸç†
published: 2025-10-08
tips:
  - AST æ˜¯å¦‚ä½•è¡¨ç¤ºç¼–ç¨‹è¯­è¨€çš„è¯­æ³•ç»“æ„çš„ï¼Ÿ
  - å¯¹è±¡å±æ€§å’Œå˜é‡ä¹‹é—´å€¼çš„ä¼ é€’æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ
tags:
  - programming language
  - æ¨è
lang: zh
abbrlink: programming-language-make
---
### 0. ä»‹ç»

> æˆ‘å¸Œæœ›äº†è§£ç¼–ç¨‹è¯­è¨€çš„çœŸæ­£æ‰§è¡Œè¿‡ç¨‹ï¼Œæœ€å¥½çš„åŠæ³•å°±æ˜¯è‡ªå·±å†™ä¸€ç§è¯­è¨€ï¼Œä½†æ˜¯ä¸éœ€è¦å…³æ³¨å¤ªå¤šåŠŸèƒ½å†…å®¹ï¼Œåªå®ç°ç®€å•çš„è„šæœ¬è¯­è¨€ï¼Œç”šè‡³ä¸å®Œå…¨å®ç°åŠ å‡ä¹˜é™¤çš„åŠŸèƒ½ã€‚ä¸ä»…ä»…æ˜¯é¢å‘å¯¹è±¡çš„è¯­è¨€ï¼ŒSQLå’ŒShellæ­¤ç±»è„šæœ¬è¯­è¨€åŒæ ·é€‚ç”¨ã€‚

å‚è€ƒé“¾æ¥ï¼š

* [Java å®ç°](https://hackernoon.com/building-your-own-programming-language-from-scratch#aboutCard)ğŸ‘ä½¿ç”¨Javaè¯­è¨€å®ç°è‡ªå·±çš„ç¼–ç¨‹è¯­è¨€ï¼ŒGithubä»“åº“å†…å®¹æ›´åŠ å®Œå¤‡ï¼Œæœ‰ç€é¢å¤–ç›¸å…³çš„åŒ…ç®¡ç†å’Œå †æ ˆä¸Šä¸‹æ–‡æ“ä½œå®ç°
* [JavaScript å®ç°](https://medium.com/@abiliu018/how-i-created-my-own-programming-language-from-scratch-9b99fa0a802b)ğŸ‘ä½¿ç”¨JSå®ç°ï¼Œå¯ä»¥å’ŒJavaçš„å¯¹ç…§ç†è§£ï¼ŒåŠ æ·±å¯¹å„ç»„ä»¶å®ç°çš„ç†è§£ã€‚
* [AST](https://astexplorer.net/)ğŸ‘ å¯ä»¥ç›´è§‚çœ‹åˆ°æ¯ç§è¯­è¨€çš„æºç ä¼šè¢«è§£ææˆä»€ä¹ˆæ ·çš„ç»“æœï¼Œå»ºè®®äº†è§£ï¼Œæ¯”è¾ƒç›´è§‚çš„ASTç»“æ„

![AST ç»“æ„](../_images/AST.png)

### 1. é«˜çº§è¯­è¨€çš„è§£æ

1. **Lexical analysis**(è¯æ³•åˆ†æ)ï¼šç”¨äºå°†æºç å†…å®¹è¿›è¡Œæ ‡è®°ï¼Œä¾‹å¦‚ä»¥Javaå’ŒJSä¸ºä¾‹ï¼Œ`new` ã€`let` ä½œä¸ºå…³é”®å­—ï¼ˆKeyWordï¼‰ï¼Œç©ºæ ¼æ¢è¡Œï¼ˆ`\t \n`ï¼‰ä½œä¸ºç©ºå­—ç¬¦ï¼Œæ“ä½œç¬¦ï¼ˆ`+` `-` `*` `/` `!`ï¼‰ç­‰ã€‚ã€‚ã€‚
2. **Syntax analysis or parser**ï¼ˆè¯­æ³•åˆ†æå™¨ï¼‰ï¼šç”¨äºå°†è¯æ³•åˆ†æåçš„æ ‡è®°è§£æç”ŸæˆASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰ï¼›
3. Evaluatorï¼šè´Ÿè´£è§£æå’Œæ‰§è¡Œä½ çš„æºä»£ç ï¼Œé€šè¿‡éå†åˆ†æå™¨ç”Ÿæˆçš„ASTå®ç°ã€‚

### 2. æœ€ç»ˆæˆæœ

> ä¸‹é¢ä¼šç»™å‡ºå…³é”®ä»£ç ï¼ˆéå…·ä½“ï¼‰ï¼Œå®Œæˆçš„è¿‡äºç®€å•ï¼Œä»…ä¾›å‚è€ƒã€‚
>
> ä¹Ÿå¯å‚è€ƒMybatisçš„org.apache.ibatis.ognlä¸‹ASTæ“ä½œ

[ä»£ç  demo](https://github.com/sansWl/OScrLan)

```java
 @SneakyThrows
    public void execute(Path path) {
        String source = Files.readString(path); //è¯»å–æºç æ–‡ä»¶
        LanguageParser lexicalParser = new LanguageParser<>(new ArrayList<>(),source);//è§£ææºç 
        List<Token> tokens = lexicalParser.parse();
        StatementParser statementParser = new StatementParser(tokens); //è¯æ€§åˆ†æ
        Statement statement = statementParser.parse();
        statement.execute(); //æ‰§è¡Œ
    }
```

```txt
struct Person
    arg name
    arg experience
    arg developer
end

input your_name
input your_experience_in_years
input is_developer

person = new Person [your_name your_experience_in_years is_developer]
print person :: name

if person :: developer then

    person_name = person :: name
    print "hey " + person_name + "!"

    experience = person :: experience

    if experience > 0 then
        started_in = 2022 + experience
        print "you had started your career in " + started_in
    end

end
```

#### 2.1 Token

> è¯å…ƒæ ‡è®°ï¼Œç›´ç™½è¯´å°±æ˜¯å¯¹æ¯ä¸ªå­—ç¬¦è¿›è¡Œåˆ†ç±»å­˜å‚¨ï¼Œæ¯”å¦‚è¯´ { a,b,v,c,d,e... }è¿™äº›å¯ä»¥æ ‡è®°ä¸ºè‹±æ–‡å­—ç¬¦,{æˆ‘ï¼Œä½ ï¼Œå¥¹......}æ ‡è®°ä¸ºä¸­æ–‡å­—ç¬¦ï¼Œè€Œå½“æˆ‘ä»¬å­¦ä¹ é«˜çº§è¯­è¨€æˆ–å…¶ä»–ç¼–ç¨‹è¯­è¨€æ—¶ï¼Œæˆ‘ä»¬æ€»ä¼šå…ˆå­¦ä¹ ä¾‹å¦‚å…³é”®å­—ï¼ˆ`new`ã€`if` ã€`while`.....ï¼‰è¿™äº›å°±å¯ä»¥æ ‡è®°ä¸ºå…³é”®å­—ï¼ŒåŒç†ï¼ˆ`>` ã€`<`ã€`*` ã€`/`ã€`=` ....ï¼‰å¯ä»¥æ ‡è®°ä¸ºæ“ä½œç¬¦,å®Œæˆèµ‹å€¼ã€è¿ç®—ç­‰åŠŸèƒ½ã€‚

```java
/**
ä»¥ä¸‹æ ‡è®°åˆ†ç±»ä½œä¸ºå‚è€ƒï¼Œå¯åœ¨ä¸Šè¿°é“¾æ¥çš„githubæ‰¾åˆ°æ›´åŠ å…¨é¢çš„åˆ†ç±»
*/
public enum TokenType {
            Whitespace("[\\s\\t\\n\\r]"),
            Keyword("(if|then|end|print|input|struct|arg|new)"),
            LogicalOperator("true|false"),
            Numeric("[0-9]+"),
            GroupDivider("(\\[|\\])"),
            Text("\"([^\"]*)\""),//åŒå¼•å·åŒ…è£¹çš„æ ‡è®°å­—ç¬¦ä¸²
            Variable("[a-zA-Z_]+[a-zA-Z0-9_]*"), //æ ‡è®°ä¸ºå˜é‡
            Operator("(\\+|\\-|\\>|\\<|\\={1,2}|\\!|\\:{2})"),//æ ‡è®°ä¸ºæ“ä½œç¬¦
            Comment(""),
            EndOfFile("");
}
/**
å­˜å‚¨è§£æçš„è¯å…ƒæ€§è´¨ï¼Œrecord æ˜¯JDK14+ ç‰¹æ€§
*/
public record Token(TokenType nameType, String value) {}

```

#### 2.2 lexicalParser

> ç®€å•æ¥è¯´ï¼Œå°±æ˜¯å°†ä½ è®¾å®šçš„æºç æ–‡ä»¶å†…å®¹å­—ç¬¦è¯»å–è¿›è¡Œæ ‡è®°åˆ†ç±»å¥½å¹¶å­˜å‚¨èµ·æ¥ï¼Œæ¯”å¦‚person **=** **new** Person [ arg1 arg2 ]  ä¸€è¡Œä¸­`person`æ ‡è®°ä¸ºå˜é‡ï¼Œ`=`æ ‡è®°ä¸ºæ“ä½œç¬¦ï¼Œ` new`æ ‡è®°ä¸ºå…³é”®å­—ç­‰ç­‰ï¼Œæ ‡è®°çš„å…·ä½“å«ä¹‰æ˜¯è‡ªå®šä¹‰çš„ã€‚

```java
  public int nextToken(int position) {
        String nextToken = source.substring(position);
        /*å¯¹æºæ–‡ä»¶çš„è¯å…ƒè¿›è¡Œåˆ†ç±»å­˜å‚¨åˆ° this.tokensé›†åˆä¸­ï¼Œ
        é›†åˆæ¨èä½¿ç”¨LinkedListä¸€ç±»çš„ï¼Œä¿è¯è¯å…ƒè§£æé¡ºåºï¼Œ
        å°¤å…¶æ˜¯ç»“æ„ä½“è¿™å—éœ€è¦æ³¨æ„ï¼Œå˜é‡å’Œå¯¹è±¡å‚æ•°çš„å¯¹åº”é¡ºåºé—®é¢˜ */
        return TokensReslove.resolve(nextToken, (List<Token>) this.tokens);
    }

// è§£æåˆ†ç±»Token
    public List<Token> parse() {
        int position = 0;
        while (position < source.length()){
            position+=nextToken(position);
        }
        return (List<Token>) tokens;
    }
```

#### 2.3 statementParser

> åˆ©ç”¨è§£æè·å¾—Tokenï¼ˆå³åˆ†ç±»å¥½çš„å•è¯ã€ç©ºæ ¼ã€personã€= ã€+ã€ã€‚ã€‚ã€‚ã€‚ã€‘ï¼‰ç»„æˆASTï¼Œæœ€åéå†æ‰§è¡Œ

```java
// æ„å»ºASTå’Œæ‰§è¡Œè¯­å¥
public Statement parseExpression() {
         Token token = nextToken(TokenType.Keyword,TokenType.Variable);
         switch (token.nameType()){
             case Keyword:
                 switch (token.value()){
                     case "if":
                         Expression condition = readExpression();
                         nextToken(TokenType.Keyword, "then"); //skip then

                         ConditionStatement conditionStatement = new ConditionStatement(condition);
                         while (!peek(TokenType.Keyword, "end")) {
                             Statement statement = parseExpression();
                             conditionStatement.add(statement);
                         }
                         nextToken(TokenType.Keyword, "end"); //skip end

                         return conditionStatement;
                     case "print":
                         Expression expression = readExpression();
                         return new PrintStatement(expression);
                     case "input":
                         Token var = nextToken(new TokenType[]{TokenType.Variable});
                         return new InputStatement(var.value(), scanner::nextLine,variables::put);
                     case "struct":
                         Token type = nextToken(new TokenType[]{TokenType.Variable});

                         Set<String> args = new LinkedHashSet<>();
                         while (!peek(TokenType.Keyword, "end")) {
                             nextToken(TokenType.Keyword, "arg");

                             Token arg = nextToken(new TokenType[]{TokenType.Variable});
                             args.add(arg.value());
                         }
                         nextToken(TokenType.Keyword, "end"); //skip end

                         structures.put(type.value(), new StructureDefinition(type.value(), new LinkedList<>(args)));

                         return null;
                 }
             case Variable:
                 nextToken(TokenType.Operator, "=");
                 Expression expression;
                 if (peek(TokenType.Keyword, "new")) {
                     expression = readInstance();
//                     expression = null;
                 } else {
                     expression = readExpression();
                 }
                 return new AssignStatement(token.value(), expression, variables::put);
             case Text:
             default:
                 throw new IllegalArgumentException("Expected keyword or variable but found " + token.nameType() + " " + token.value());
         }

    }

  //è§£ætokenç»„æˆAST
    public Statement parse() {
        CompositeStatement root = new CompositeStatement();
        while (position < tokens.size()) {
            Statement statement = parseExpression();
            root.add(statement);
        }
    // rootä¸‹åŒ…å«ç€éœ€è¦æ‰§è¡Œçš„æ“ä½œè¯­å¥ï¼Œæ¯”å¦‚æ„å»ºå¯¹è±¡ï¼Œifåˆ¤æ–­ï¼Œè¾“å…¥ï¼Œè¾“å‡ºç­‰è¯­å¥
        return root;
    }

    @Override
    public void execute() {
       // root  æ‰§è¡Œè¯­å¥
        for (Statement statement : statements) {
            statement.execute();
        }
    }

```

#### 2.4 é—®é¢˜

* å˜é‡å’Œå¯¹è±¡å‚æ•°é¡ºåºé—®é¢˜ï¼š

```txt
  struct Person
      arg name
      arg experience
      arg developer
  end
  input your_name
  input your_experience_in_years
  input is_developer
  //nameã€experienceã€developerè¢«èµ‹å€¼éœ€è¦å’Œå˜é‡é¡ºåºä¸€è‡´ï¼Œä½†æ˜¯å¦‚æœä½ ä½¿ç”¨hashmapå­˜å‚¨å‚æ•°ä¼šå¯¼è‡´é¡ºåºä¸ºnameã€developerã€experience
  person = new Person [your_name your_experience_in_years is_developer]
```

* å¦‚ä½•æ‰“åŒ…æˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Ÿè¦æ±‚ JDK 14 +
  [Javaæ‰“åŒ…å·¥å…·jpackage - å®˜æ–¹æ–‡æ¡£](https://docs.oracle.com/en/java/javase/21/jpackage/preface.html#GUID-C8F52DC6-0750-497D-9DAB-2F88E10787BE)
  [Jpackage-åˆ¶ä½œæ— éœ€é¢„è£…Javaç¯å¢ƒçš„Jarå¯æ‰§è¡Œç¨‹åº](https://segmentfault.com/a/1190000044693072)

### 3. æ‰©å±•ï¼ˆå¯å¢å¼ºå­¦ä¹ ç‚¹ï¼‰

* å†…å­˜ä¸Šä¸‹æ–‡ï¼šæ ˆã€å †ã€é™æ€å˜é‡ã€å¸¸é‡æ± ã€æ–¹æ³•åŒºç­‰
* åŒ…ç®¡ç†ï¼šç±»ä¼¼Javaçš„åŒ…ç®¡ç†æœºåˆ¶ï¼ŒåŒ…æ‹¬åŒ…çš„å¯¼å…¥ã€å¯¼åŒ…ã€ç±»çš„åŠ è½½ã€ç±»çš„å†²çªè§£å†³ç­‰ã€‚
* å¼‚å¸¸å¤„ç†ï¼štry-catch-finally
* å¤šçº¿ç¨‹ï¼šçº¿ç¨‹åˆ›å»ºã€åŒæ­¥ã€é”ã€æ­»é”ã€çº¿ç¨‹æ± ï¼ˆçº¿ç¨‹çš„æœ¬è´¨å°±æ˜¯åˆ›é€ ä¸€ä¸ªå…³äºæ“ä½œç¬¦çš„å †æ ˆï¼‰
* GCï¼šåƒåœ¾å›æ”¶ç®—æ³•ã€åƒåœ¾å›æ”¶å™¨ã€å†…å­˜åˆ†é…ç­–ç•¥ã€å†…å­˜ç¢ç‰‡ã€å†…å­˜æ³„æ¼
* è¯­æ³•ç³–ï¼šè¯­æ³•ç³–æ˜¯æŒ‡ä¸€äº›è¯­æ³•çš„æ‰©å±•ï¼Œæ¯”å¦‚Javaä¸­çš„Stream APIã€Lambdasè¡¨è¾¾å¼ã€Optionalç±»ç­‰ã€‚
